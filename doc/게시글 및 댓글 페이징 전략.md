## 페이징 전략

이번 REST API 중에서 제일 신경 쓴 부분은 페이징을 적용한 게시글 목록 조회 API라고 생각합니다. Spring Data JPA에서 제공해주는 Pageable을 통해서 편리하게 페이징 처리가 가능하지만, 이 클래스는 한계가 존재하였습니다. 

일단 페이지 번호와 페이지 크기 값을 제한할 수 없었습니다.  예를 들어서 페이지 번호가 -1이고, 페이지 사이즈가 100이 넘는 데이터가 들어온다면 디폴트 값으로 처리 할 수 있는 방법이 없습니다. 그래서 Custom PageRequest 클래스를 구현하여 setter를 커스텀하여 특정 조건의 페이지 크기와 수를 넘어가면 조정할 수 있도록 아래와 같이 구현하였습니다.

```java
class PageRequest {
    var page: Int = 1
        set(value) {
            field = if (value <= 0) 1 else value
        }

    var size: Int = 10
        set(value) {
            println("value: $value")
            field = if (value > DEFAULT_MAX_SIZE) DEFAULT_SIZE else value
         }

    var direction: Sort.Direction = Sort.Direction.ASC

    companion object {
        const val DEFAULT_SIZE = 10
        const val DEFAULT_MAX_SIZE = 50
    }

    fun of(): PageRequest {
        return PageRequest.of(page - 1, size, direction, "createdDate")
    }
}
```

```java
@GetMapping
fun list(
    @RequestParam(name = "type")  type: BoardSearchType,
    @RequestParam(name = "value", required = false) value: String?,
    pageRequest: PageRequest
): Page<BoardDto.Res> {

    logger.debug("type: ${type.name}")
    logger.debug("value: $value")
    logger.debug("pageRequest: ${pageRequest.page}")
    logger.debug("pageRequest: ${pageRequest.size}")

    return boardSearchService.search(type, value, pageRequest.of()).map(Board::toRes)
}
```

type(검색 키워드), value(검색 값)과 Paging 정보를 get 방식으로 파라미터를 받아서 페이징 처리하는 Controller 부분입니다.


Spring Data JPA에서 제공하는 페이징을 QueryDSL에서 사용하려면 아래와 같이 QuerydslRepositorySupport 추상 클래스를 상속받으면 쉽게 사용할 수 있습니다.

```java
@Service
@Transactional(readOnly = true)
class BoardSearchService: QuerydslRepositorySupport(Board::class.java) {

    fun search(type: BoardSearchType, value: String?, pageable: Pageable): Page<Board> {
        val board: QBoard = QBoard.board
        var query: JPQLQuery<Board>? = null
        query = from(board).where(searchBoardByCond(board, type, value))
        val boards: List<Board> = querydsl!!.applyPagination(pageable, query!!).fetch()
        return PageImpl(boards, pageable, query!!.fetchCount())
    }

    fun searchBoardByCond(board: QBoard, searchType: BoardSearchType, value: String?): BooleanBuilder {
        val builder = BooleanBuilder()

        when (searchType) {
            AUTHOR -> if (hasText(value)) builder.and(board.author.likeIgnoreCase("$value%"))
            TITLE -> if (hasText(value)) builder.and(board.title.likeIgnoreCase("%$value%"))
            CONTENT -> if (hasText(value)) builder.and(board.content.likeIgnoreCase("%$value%"))
            else -> InvalidException("Type is not exist: ${searchType.name}")
        }
        return builder
    }
}
```

Java에서 swich ~ case문 대신에 코틀린 답게 when 절을 이용하여 동적으로 쿼리를 생성하고 querydsl의 applyPagination() 메서드에 페이징 처리 정보와 동적으로 생성한 JPQL`<Board>` 구현체를 인자로 넘겨서 호출하면 페이징을 적용한 쿼리를 DBMS에 하이버네이트가 전달하게 됩니다. 

### Response Body 

아래 Response Body는 요청 시 페이지 번호 1, 페이지 크기는 10으로 조회 요청한 결과 화면입니다.

![image](https://user-images.githubusercontent.com/22395934/119020784-9ee85480-b9d9-11eb-9d38-00c1592ec3ad.png)

